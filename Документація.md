# Документація проекту "Dungeon Master"

  

## Зміст

- [Вступ](#вступ)

- [Структура проекту](#структура-проекту)

- [Основні файли](#основні-файли)

  - [main.py](#mainpy)

  - [menu.py](#menupy)

  - [game.py](#gamepy)

  - [config.py](#configpy)

- [Спрайти](#спрайти)

  - [base.py](#basepy)

  - [player.py](#playerpy)

  - [enemy.py](#enemypy)

  - [bullet.py](#bulletpy)

- [Управління ресурсами](#управління-ресурсами)

  - [resources.py](#resourcespy)

  - [sprite_manager.py](#sprite_managerpy)

- [Рівні та камера](#рівні-та-камера)

  - [level.py](#levelpy)

  - [camera.py](#camerapy)

- [Інтерфейс](#інтерфейс)

  - [buttons.py](#buttonspy)

- [Приклади використання](#приклади-використання)

  - [enemy_sprite_example.py](#enemy_sprite_examplepy)

  - [sprite_sheet_example.py](#sprite_sheet_examplepy)

- [Технічні деталі](#технічні-деталі)

  - [Система анімацій](#система-анімацій)

  - [Система колізій](#система-колізій)

  - [Керування звуком](#керування-звуком)

- [Інструкція з розширення проекту](#інструкція-з-розширення-проекту)

  

---

  

## Вступ

  

"Dungeon Master" - це гра, розроблена на фреймворку Pygame, що представляє собою 2D пригоду в стилі данжен-кроулер. Гравець керує героєм, який повинен перемогти ворогів, зібрати ключ та знайти вихід із підземелля.

  

Ця документація є повним описом структури та функціональності проекту, що допоможе розробникам розібратися з кодом та розширити можливості гри.

  

## Структура проекту

  

Проект розділений на логічні модулі, кожен з яких відповідає за окрему частину функціональності:

  

1. **Основні файли** - запуск гри, головне меню, основна логіка гри

2. **Спрайти** - класи для різних ігрових об'єктів

3. **Управління ресурсами** - завантаження та керування ресурсами гри

4. **Рівні та камера** - створення рівнів, колізії, камера відстеження

5. **Інтерфейс** - елементи користувацького інтерфейсу

6. **Приклади** - демонстраційні файли для тестування функціоналу

  

## Основні файли

  

### main.py

  

Це точка входу в програму, яка ініціює запуск гри та забезпечує правильне завершення роботи.

  

```python

import pygame

import sys

from menu import Menu

  

def main():

    """

    Головна функція, яка запускає гру.

    Створює екземпляр меню та обробляє правильне завершення програми.

    """

    try:

        menu = Menu()  # Створення об'єкту меню

        menu.run()     # Запуск головного циклу меню

    finally:

        # Гарантоване звільнення ресурсів при завершенні

        pygame.quit()  # Закриття підсистем Pygame

        sys.exit()     # Завершення програми

  

if __name__ == "__main__":

    main()

```

  

### menu.py

  

Клас `Menu` відповідає за відображення головного меню гри, обробку натискань кнопок та перехід до гри.

  

```python

class Menu:

    """

    Клас для управління головним меню гри.

    Відповідає за:

    - Відображення фону та кнопок меню

    - Обробку натискань кнопок

    - Запуск основної гри

    - Відтворення фонової музики

    """

    def __init__(self):

        # Ініціалізація pygame та підсистеми звуку

        # Створення вікна з заданими розмірами

        # Завантаження зображень фону та заголовку

        # Завантаження та налаштування фонової музики

        # Створення кнопок з активним та пасивним станом

        # ...existing code...

  

    def handle_events(self):

        """

        Обробка подій меню (натискання кнопок, закриття вікна).

        Перевіряє події Pygame та реагує на них, передаючи

        відповідні події кнопкам або закриваючи гру.

        """

        # ...existing code...

  

    def update(self):

        """

        Оновлення стану кнопок при наведенні курсору.

        Отримує поточну позицію курсора і передає її

        кожній кнопці для перевірки наведення.

        """

        # ...existing code...

  

    def render(self):

        """

        Відмальовування елементів меню на екрані.

        Малює фон, заголовок та всі кнопки меню

        з урахуванням їх поточного стану.

        """

        # ...existing code...

  

    def start_game(self):

        """

        Запуск основної гри та призупинення музики меню.

        Зупиняє фонову музику меню, створює об'єкт гри

        і запускає її основний цикл.

        """

        # ...existing code...

  

    def quit_game(self):

        """

        Коректне завершення роботи гри.

        Зупиняє всі аудіо потоки, закриває Pygame

        і завершує роботу програми.

        """

        # ...existing code...

  

    def run(self):

        """

        Головний цикл меню.

        Безперервно обробляє події, оновлює стан

        і відмальовує меню до тих пір, поки не буде вибрано

        запуск гри або завершення програми.

        """

        # ...existing code...

```

  

### game.py

  

Клас `Game` реалізує основну логіку гри, включаючи створення персонажів, обробку подій, оновлення стану та відображення.

  

```python

class Game:

    """

    Головний клас гри, що відповідає за:

    - Ініціалізацію ігрових об'єктів (гравець, вороги, перешкоди)

    - Обробку користувацького вводу

    - Оновлення стану гри

    - Відображення ігрового світу

    - Обробку колізій та подій

    """

    def __init__(self, background_music=None):

        """

        Ініціалізує гру, створюючи вікно, камеру, спрайти та рівень.

        Параметри:

            background_music - Посилання на фонову музику з меню

                              для можливості відновлення її пізніше

        """

        # Ініціалізація Pygame

        # Створення вікна гри

        # Створення камери з обмеженим полем зору

        # Завантаження фонових зображень для різних станів гри

        # Створення менеджера спрайтів для керування всіма об'єктами

        # Створення рівня, гравця та ворогів

        # Ініціалізація стану клавіш керування

        # ...existing code...

  

    def handle_events(self):

        """

        Обробляє події клавіатури та миші для керування гравцем.

        Реагує на натискання та відпускання клавіш, оновлює

        відповідні стани руху та атаки гравця.

        """

        # Обробка всіх подій Pygame

        # Реакція на закриття вікна

        # Керування рухом гравця (WASD)

        # Керування атаками гравця (стрілки)

        # ...existing code...

  

    def update(self):

        """

        Оновлює стан усіх ігрових об'єктів, перевіряє колізії,

        обробляє логіку гри (перемога/поразка).

        Послідовно оновлює:

        - стан гравця

        - стан куль

        - стан ворогів

        - перевіряє всі колізії

        """

        # Перевірка стану гри (завершена/триває)

        # Оновлення стану гравця та його анімацій

        # Оновлення куль та перевірка їх влучень

        # Оновлення ворогів та їх анімацій

        # Перевірка підбору ключа гравцем

        # Перевірка зіткнення гравця з ворогами (поразка)

        # Перевірка досягнення виходу з ключем (перемога)

        # ...existing code...

  

    def render(self):

        """

        Відображає ігровий світ з урахуванням положення камери.

        Використовує систему камери для відображення тільки

        частини світу навколо гравця.

        """

        # Очищення поверхні для зуму

        # Оновлення позиції камери відповідно до позиції гравця

        # Відображення фону з урахуванням позиції камери

        # Відображення всіх спрайтів з урахуванням зміщення камери

        # Відображення підказок та додаткової інформації

        # Масштабування зображення камери на весь екран

        # Або відображення екрану перемоги/поразки

        # ...existing code...

  

    def run(self):

        """

        Запускає основний ігровий цикл.

        Безперервно обробляє введення, оновлює стан гри

        і відображає її на екрані з обмеженням частоти кадрів.

        """

        # Цикл, що працює поки гра активна

        # Обробка подій

        # Оновлення стану гри

        # Відображення ігрового світу

        # Обмеження FPS

        # ...existing code...

```

  

### config.py

  

Цей файл містить константи та налаштування, які використовуються в різних частинах гри.

  

```python

"""

Файл з константами та конфігурацією:

- Розміри вікна

- Кольори

- Швидкості руху

- Налаштування FPS

- Шляхи до файлів ресурсів

- Розміри об'єктів

- Налаштування клавіш керування

"""

# Розміри вікна гри

WINDOW_WIDTH = 700   # Ширина вікна в пікселях

WINDOW_HEIGHT = 500  # Висота вікна в пікселях

  

# Визначення основних кольорів

BLACK = (0, 0, 0)    # Чорний колір (RGB)

  

# Налаштування швидкості руху гравця

PLAYER_SPEED = 12    # Базова швидкість руху гравця

  

# Частота кадрів для плавної анімації

FPS = 15             # Кількість кадрів за секунду

  

# Шляхи до файлів ресурсів (зображення, звуки)

BG_IMAGE = "background/game.png"     # Фон гри

WIN_IMAGE = "background/Winer.png"   # Повідомлення про перемогу

# ... інші шляхи до ресурсів ...

  

# Розміри ігрових об'єктів

PLAYER_SIZE = (1, 3)     # Розмір гравця

ENEMY_SIZE = (27, 42)    # Розмір ворога

BULLET_RIGHT_SIZE = (31, 5)  # Розмір кулі вправо

BULLET_LEFT_SIZE = (31, 5)   # Розмір кулі вліво

  

# Налаштування клавіш керування

CONTROLS = {

    'MOVE_UP': K_w,          # Рух вгору

    'MOVE_DOWN': K_s,        # Рух вниз

    'MOVE_LEFT': K_a,        # Рух ліворуч

    'MOVE_RIGHT': K_d,       # Рух праворуч

    'ATTACK_LEFT': K_LEFT,   # Атака ліворуч

    'ATTACK_RIGHT': K_RIGHT  # Атака праворуч

}

  

# Альтернативне налаштування керування (закоментоване)

# CONTROLS = {

#     'MOVE_UP': K_e,

#     # ... інші клавіші ...

# }

```

  

## Спрайти

  

### base.py

  

Базовий клас для всіх ігрових об'єктів.

  

```python

class GameSprite(pygame.sprite.Sprite):

    """

    Базовий клас для всіх ігрових спрайтів.

    Забезпечує базовий функціонал:

    - Завантаження зображення

    - Створення прямокутника для колізій

    - Встановлення початкової позиції

    - Метод для відображення спрайту

    """

    def __init__(self, picture, width, height, x, y):

        """

        Ініціалізує спрайт з вказаним зображенням та розмірами.

        Параметри:

            picture - шлях до файлу зображення

            width - ширина спрайту в пікселях

            height - висота спрайту в пікселях

            x - початкова X-координата спрайту

            y - початкова Y-координата спрайту

        """

        super().__init__()

        # Завантаження та масштабування зображення

        # Створення прямокутника для колізій

        # Встановлення початкової позиції

        # ...existing code...

    def reset(self, surface):

        """

        Відмальовує спрайт на вказаній поверхні.

        Параметри:

            surface - поверхня Pygame для відображення

        """

        # Відображення зображення спрайту на поверхні

        # ...existing code...

```

  

### player.py

  

Клас, що реалізує гравця та його поведінку.

  

```python

class Player(GameSprite):

    """

    Клас гравця з системою руху та атаки.

    Функціонал:

    - Рух у чотирьох напрямках

    - Стрільба влучними снарядами

    - Обробка колізій з перешкодами

    - Анімації руху та атаки

    """

    def __init__(self, picture, width, height, x, y, x_speed, y_speed, animations):

        """

        Ініціалізує гравця з заданими параметрами та анімаціями.

        Параметри:

            picture - шлях до початкового зображення

            width, height - розміри спрайту

            x, y - початкова позиція

            x_speed, y_speed - початкові швидкості

            animations - словник з усіма анімаціями гравця

        """

        # Ініціалізація базового класу

        # Встановлення базової швидкості руху

        # Ініціалізація станів руху та атаки

        # Ініціалізація індексів для анімацій

        # Запам'ятовування останнього напрямку для анімації спокою

        # ...existing code...

  

    def update_movement(self):

        """

        Оновлює швидкість руху на основі натиснутих клавіш.

        Також нормалізує діагональний рух для збереження постійної швидкості.

        """

        # Перевірка стану атаки (під час атаки гравець не рухається)

        # Скидання швидкості руху

        # Встановлення горизонтальної та вертикальної швидкості

        # Нормалізація діагональної швидкості (щоб діагональний рух не був швидшим)

        # ...existing code...

    def update(self, barriers):

        """

        Оновлює позицію гравця з урахуванням перешкод.

        Проводить перевірку колізій окремо по X та Y осям для точного руху.

        Параметри:

            barriers - група спрайтів перешкод для перевірки колізій

        """

        # Оновлення швидкості руху

        # Переміщення по горизонталі і обробка колізій

        # Переміщення по вертикалі і обробка колізій

        # Перевірка меж екрану

        # ...existing code...

    def fire_right(self):

        """

        Створює снаряд для стрільби вправо.

        Повертає об'єкт створеного снаряду.

        """

        # Створення кулі з правильним зображенням та швидкістю

        # ...existing code...

    def fire_left(self):

        """

        Створює снаряд для стрільби вліво.

        Повертає об'єкт створеного снаряду.

        """

        # Створення кулі з правильним зображенням та швидкістю

        # ...existing code...

    def update_animation(self):

        """

        Оновлює анімацію гравця залежно від поточного стану.

        Пріоритет мають анімації атаки, потім руху, потім спокою.

        Повертає створений снаряд, якщо гравець стріляє,

        або None в іншому випадку.

        """

        # Анімація атаки (якщо активна)

        # Створення снаряда в потрібний момент анімації

        # Якщо не атакує, то анімація руху

        # Якщо не рухається, то анімація спокою

        # ...existing code...

    # Методи для керування рухом та атакою

    def start_left_move(self):

        """Починає рух вліво"""

        # ...existing code...

    def start_right_move(self):

        """Починає рух вправо"""

        # ...existing code...

    # ... інші методи керування рухом та атаки ...

```

  

### enemy.py

  

Клас, що реалізує ворогів та їх поведінку.

  

```python

class Enemy(GameSprite):

    """

    Клас ворога з патрульною поведінкою та анімацією смерті.

    Функціонал:

    - Автоматичний рух по заданому маршруту

    - Анімації руху та смерті

    - Створення могили та ключа після загибелі

    """

    def __init__(self, picture, width, height, x, y, speed_x, speed_y, animations):

        """

        Ініціалізує ворога з заданими параметрами та анімаціями.

        Параметри:

            picture - шлях до початкового зображення

            width, height - розміри спрайту

            x, y - початкова позиція

            speed_x, speed_y - початкові швидкості

            animations - словник з усіма анімаціями ворога

        """

        # Ініціалізація базового класу

        # Ініціалізація швидкостей руху

        # Ініціалізація станів руху та смерті

        # Ініціалізація індексів для анімацій

        # ...existing code...

    def update(self):

        """

        Оновлює позицію та стан ворога.

        Реалізує логіку патрулювання по прямокутному маршруту.

        """

        # Перевірка стану смерті (мертвий ворог не рухається)

        # Оновлення позиції з урахуванням швидкості

        # Логіка зміни напрямку руху для патрулювання

        # ...existing code...

    def start_death(self):

        """

        Запускає анімацію смерті ворога.

        Зупиняє рух і скидає індекс анімації смерті.

        """

        # Встановлення стану смерті

        # Зупинка руху

        # Скидання індексу анімації смерті

        # ...existing code...

    def update_animation(self):

        """

        Оновлює анімацію ворога відповідно до поточного стану.

        Обробляє анімацію смерті або анімацію руху.

        """

        # Анімація смерті, якщо ворог помирає

        # Інакше анімація руху в поточному напрямку

        # ...existing code...

    def create_grave_and_key(self):

        """

        Створює могилу на місці загиблого ворога та ключ.

        Повертає обидва об'єкти для додавання в гру.

        """

        # Створення могили з останньої анімації смерті

        # Створення ключа в позиції смерті ворога

        # ...existing code...

```

  

### bullet.py

  

Клас для представлення снарядів, випущених гравцем.

  

```python

class Bullet(GameSprite):

    """

    Клас снаряда (кулі/стріли), який може рухатися і вражати цілі.

    Функціонал:

    - Рух з постійною швидкістю

    - Виявлення колізій з ворогами та перешкодами здійснюється в Game.update()

    """

    def __init__(self, picture, width, height, x, y, speed):

        """

        Ініціалізує снаряд з заданими параметрами.

        Параметри:

            picture - шлях до зображення снаряда

            width, height - розміри снаряда

            x, y - початкова позиція

            speed - швидкість руху (може бути додатною або від'ємною)

        """

        # Ініціалізація базового класу

        # Збереження швидкості снаряда

        # ...existing code...

    def update(self):

        """

        Оновлює позицію снаряда з урахуванням його швидкості.

        Снаряд рухається тільки по горизонталі.

        """

        # Оновлення X-координати з урахуванням швидкості

        # ...existing code...

```

  

## Управління ресурсами

  

### resources.py

  

Клас для завантаження та керування ігровими ресурсами.

  

```python

class ResourceManager:

    """

    Статичний клас для завантаження та керування ігровими ресурсами.

    Методи:

    - load_image: завантаження зображень з опціональним масштабуванням

    - load_animation: завантаження списку зображень для анімації

    """

    @staticmethod

    def load_image(path, size=None):

        """

        Завантажує зображення з опціональним масштабуванням.

        Параметри:

            path - шлях до файлу зображення

            size - кортеж (ширина, висота) для масштабування або None

        Повертає:

            Завантажене зображення як Surface

        """

        # Завантаження зображення

        # Опціональне масштабування, якщо розмір вказано

        # ...existing code...

  

    @staticmethod

    def load_animation(paths, sizes=None):

        """

        Завантажує список зображень для анімації.

        Параметри:

            paths - список шляхів до зображень

            sizes - кортеж (ширина, висота) для масштабування або None

        Повертає:

            Список завантажених зображень

        """

        # Завантаження та опціональне масштабування всіх зображень

        # ...existing code...

  

# Функції для завантаження комплектів анімацій

def load_player_animations():

    """

    Завантажує і повертає набір анімацій для гравця.

    Повертає:

        Словник з усіма анімаціями гравця, організованими по типам

    """

    # Завантаження анімацій бігу в різних напрямках

    # Завантаження анімацій атаки

    # Завантаження зображень для стану спокою

    # ...existing code...

  

def load_enemy_animations():

    """

    Завантажує і повертає набір анімацій для ворогів.

    Повертає:

        Словник з усіма анімаціями ворога, організованими по типам

    """

    # Завантаження анімацій руху в різних напрямках

    # Завантаження анімації смерті

    # ...existing code...

  

def load_tips():

    """

    Завантажує і повертає зображення для підказок.

    Повертає:

        Словник з усіма зображеннями підказок

    """

    # Завантаження зображень для різних підказок

    # ...existing code...

```

  

### sprite_manager.py

  

Центральний менеджер для всіх спрайтів гри.

  

```python

class SpriteManager:

    """

    Клас для централізованого управління всіма спрайтами в грі.

    Функціонал:

    - Збереження спрайтів у відповідних групах

    - Додавання/видалення спрайтів

    - Оновлення та відображення всіх спрайтів

    - Очищення груп спрайтів

    """

    def __init__(self):

        """

        Створює групи для різних типів спрайтів.

        Ініціалізує основну групу та підгрупи за призначенням.

        """

        # Створення головної групи для всіх спрайтів

        # Створення спеціалізованих груп (бар'єри, кулі, вороги, тощо)

        # Створення словника для швидкого доступу до груп за іменем

        # ...existing code...

    def add(self, sprite, *groups):

        """

        Додає спрайт у вказані групи та в загальну групу.

        Параметри:

            sprite - спрайт для додавання

            groups - імена груп ('barriers', 'bullets', тощо)

        """

        # Додавання спрайту до загальної групи

        # Додавання до кожної вказаної групи

        # ...existing code...

    def remove(self, sprite, *groups):

        """

        Видаляє спрайт із вказаних груп.

        Параметри:

            sprite - спрайт для видалення

            groups - імена груп; якщо не вказано - видаляє з усіх груп

        """

        # Якщо групи не вказані, видалення з усіх груп

        # Інакше видалення тільки з вказаних груп

        # ...existing code...

    def get_group(self, group_name):

        """

        Повертає групу спрайтів за іменем.

        Параметри:

            group_name - назва групи

        Повертає:

            Групу спрайтів або порожню групу, якщо ім'я не знайдено

        """

        # Повернення групи за іменем або порожньої групи

        # ...existing code...

    def update(self, *args, **kwargs):

        """

        Оновлює всі спрайти.

        Передає аргументи методу update() всіх спрайтів.

        """

        # Виклик update() для всієї групи спрайтів

        # ...existing code...

    def draw(self, surface):

        """

        Відображає всі спрайти на вказаній поверхні.

        Параметри:

            surface - поверхня Pygame для відображення

        """

        # Виклик draw() для всієї групи спрайтів

        # ...existing code...

    def empty_group(self, group_name):

        """

        Очищує вказану групу спрайтів.

        Видаляє спрайти з вказаної групи і, якщо вони не присутні

        в інших групах, також видаляє їх з загальної групи.

        Параметри:

            group_name - назва групи для очищення

        """

        # Отримання списку спрайтів у групі

        # Видалення кожного спрайту з групи

        # Перевірка, чи є спрайт в інших групах

        # Якщо немає, видалення його з загальної групи

        # ...existing code...

```

  

## Рівні та камера

  

### level.py

  

Клас для створення та управління ігровим рівнем.

  

```python

class Level:

    """

    Клас для створення та управління ігровим рівнем.

    Функціонал:

    - Створення перешкод та об'єктів рівня

    - Обробка колізій

    - Керування підказками

    - Логіка підбирання ключа та відкриття дверей

    """

    def __init__(self, sprite_manager=None):

        """

        Ініціалізує рівень з використанням заданого менеджера спрайтів.

        Параметри:

            sprite_manager - існуючий менеджер спрайтів або None

                            (тоді буде створено новий)

        """

        # Використання переданого менеджера спрайтів або створення нового

        # Ініціалізація посилань на групи спрайтів

        # Ініціалізація об'єктів рівня (двері, підказки)

        # Ініціалізація прапорців стану (ключ зібрано тощо)

        # ...existing code...

    def create_barriers(self):

        """

        Створює перешкоди на рівні (стіни, об'єкти).

        Кожна перешкода визначається позицією та розміром.

        """

        # Визначення даних для кожної перешкоди

        # Створення спрайтів перешкод і додавання їх до групи бар'єрів

        # ...existing code...

    def create_level_objects(self, tips):

        """

        Створює об'єкти рівня (двері, підказки та ін.).

        Параметри:

            tips - словник з зображеннями для підказок

        """

        # Створення дверей для завершення рівня

        # Створення підказок для гравця

        # ...existing code...

    def update_tips(self, tips, surface):

        """

        Оновлює стан підказок.

        Параметри:

            tips - словник з зображеннями для підказок

            surface - поверхня для відображення підказок

        """

        # Відображення необхідних підказок залежно від стану гри

        # ...existing code...

    def check_key_collection(self, hero):

        """

        Перевіряє підбирання ключа гравцем.

        Якщо ключ зібрано, оновлює підказки та встановлює відповідний прапор.

        Параметри:

            hero - об'єкт гравця для перевірки зіткнення з ключем

        Повертає:

            True, якщо ключ був зібраний, False в іншому випадку

        """

        # Перевірка зіткнення гравця з ключем

        # Видалення ключа та оновлення стану гри і підказок

        # ...existing code...

    def check_bullet_collisions(self, tips):

        """

        Перевіряє зіткнення куль з ворогами та перешкодами.

        Повертає відомості про влучення у ворога.

        Параметри:

            tips - словник з зображеннями для підказок

        Повертає:

            Кортеж (був_влучений_ворог, об'єкт_враженого_ворога)

        """

        # Перевірка всіх куль на зіткнення з ворогами

        # При влученні запуск анімації смерті ворога

        # Перевірка зіткнень куль з перешкодами

        # ...existing code...

    def add_grave_and_key(self, grave, key):

        """

        Додає могилу та ключ після смерті ворога.

        Параметри:

            grave - об'єкт могили

            key - об'єкт ключа

        """

        # Додавання могили та ключа до відповідних груп

        # Оновлення видимості підказок

        # ...existing code...

```

  

### camera.py

  

Клас для реалізації камери, яка слідує за гравцем.

  

```python

class Camera:

    """

    Клас камери для відстеження гравця.

    Реалізує систему відображення частини ігрового світу

    з масштабуванням для кращої видимості.

    """

    def __init__(self, width, height, zoom_width=200, zoom_height=200):

        """

        Ініціалізує камеру з заданими розмірами вікна та областю видимості.

        Параметри zoom_width та zoom_height визначають розмір області, що відстежується.

        Параметри:

            width, height - розміри вікна гри

            zoom_width, zoom_height - розміри області видимості

        """

        # Збереження розмірів вікна

        # Встановлення розмірів зуму

        # Ініціалізація зміщення камери

        # Створення поверхні для зуму

        # Розрахунок коефіцієнту масштабування

        # ...existing code...

  

    def update(self, target):

        """

        Оновлює положення камери, щоб вона була центрована на цілі (гравці).

        Відслідковування відбувається без згладжування для точного слідування.

        Параметри:

            target - об'єкт, за яким слідує камера (зазвичай гравець)

        """

        # Центрування камери на цілі

        # ...existing code...

  

    def apply(self, entity):

        """

        Перераховує координати об'єкта відносно камери.

        Використовується для коректного відображення спрайтів на екрані.

        Параметри:

            entity - об'єкт, координати якого треба перерахувати

        Повертає:

            Новий прямокутник з координатами відносно камери

        """

        # Створення прямокутника з координатами відносно камери

        # ...existing code...

    def apply_rect(self, rect):

        """

        Перераховує координати прямокутника відносно камери.

        Використовується для коректного відображення фону та нерухомих об'єктів.

        Параметри:

            rect - прямокутник, координати якого треба перерахувати

        Повертає:

            Новий прямокутник з координатами відносно камери

        """

        # Створення прямокутника з координатами відносно камери

        # ...existing code...

```

  

## Інтерфейс

  

### buttons.py

  

Клас для створення і управління кнопками в інтерфейсі.

  

```python

class ImageButton:

    """

    Клас для кнопки з зображенням.

    Функціонал:

    - Відображення звичайного та активного станів (при наведенні)

    - Відтворення звуку при натисканні

    - Генерація події при натисканні

    - Налаштування гучності звуку

    """

    def __init__(self, x, y, width, height, image_path, hover_image_path=None, sound_path=None, sound_volume=0.3):

        """

        Ініціалізує кнопку з заданими параметрами.

        Можна вказати звук натискання та окреме зображення для стану наведення.

        Параметри:

            x, y - позиція кнопки на екрані

            width, height - розміри кнопки

            image_path - шлях до зображення кнопки

            hover_image_path - шлях до зображення для стану наведення (опціонально)

            sound_path - шлях до звуку натискання (опціонально)

            sound_volume - гучність звуку (0.0 - 1.0)

        """

        # Збереження позиції та розмірів

        # Завантаження та масштабування зображень

        # Створення прямокутника для визначення наведення

        # Завантаження звуку з вказаною гучністю

        # Ініціалізація стану наведення

        # ...existing code...

  

    def draw(self, surface):

        """

        Відображає кнопку на вказаній поверхні з урахуванням стану наведення.

        Параметри:

            surface - поверхня Pygame для відображення кнопки

        """

        # Вибір поточного зображення залежно від стану наведення

        # Відображення на вказаній поверхні

        # ...existing code...

  

    def check_hover(self, mouse_pos):

        """

        Перевіряє, чи наведено курсор на кнопку.

        Параметри:

            mouse_pos - поточна позиція курсора миші

        """

        # Оновлення стану наведення

        # ...existing code...

    def handle_event(self, event):

        """

        Обробляє події миші для кнопки.

        При натисканні відтворює звук та генерує подію.

        Параметри:

            event - подія Pygame для обробки

        """

        # Перевірка, чи це натискання лівої кнопки миші

        # Відтворення звуку при натисканні

        # Генерація користувацької події з посиланням на кнопку

        # ...existing code...

    def set_sound_volume(self, volume):

        """

        Встановлює гучність звуку натискання кнопки.

        Параметри:

            volume - нова гучність (0.0 - 1.0)

        """

        # Встановлення гучності звуку, якщо він існує

        # ...existing code...

```

  

## Приклади використання

  

### enemy_sprite_example.py

  

Приклад використання спрайтів ворога для демонстрації анімацій.

  

```python

"""

Демонстраційний файл для тестування анімацій ворога.

Дозволяє переглядати різні анімації руху та смерті.

Керування: стрілки для вибору анімації руху, пробіл для анімації смерті.

"""

# Ініціалізація Pygame

# Створення вікна

# Завантаження спрайт-листа ворога

# Розділення спрайт-листа на окремі кадри анімації

# Групування спрайтів за типами анімацій (рух вправо, вліво тощо)

# Обробка клавіш для зміни поточної анімації

# Відображення поточного кадру анімації

# Основний цикл з обмеженням FPS

# ...existing code...

```

  

### sprite_sheet_example.py

  

Приклад завантаження та використання спрайт-листа.

  

```python

"""

Демонстраційний файл для тестування завантаження спрайт-листа.

Показує, як можна розділити спрайт-лист на окремі кадри та використовувати їх для анімації.

"""

# Ініціалізація Pygame

# Створення вікна

# Визначення параметрів спрайт-листа (шлях, розміри, кількість рядків і стовпців)

# Завантаження спрайт-листа

# Розділення на окремі спрайти для анімації

# Основний цикл для демонстрації анімації

# ...existing code...

```

  

## Технічні деталі

  

### Система анімацій

  

Гра використовує кадрову анімацію, реалізовану через зміну спрайтів. Анімації зберігаються у вигляді списків зображень, організованих за типами дій.

  

Основні принципи роботи системи анімацій:

1. **Завантаження**: Анімації завантажуються при ініціалізації гри через `resources.py`

2. **Організація**: Анімації зберігаються в словниках за типами (`run_left`, `attack_right`, тощо)

3. **Відтворення**: На кожному кадрі гри викликається метод `update_animation()`, який:

   - Визначає поточний стан об'єкта (атака, рух, спокій)

   - Вибирає відповідну анімацію

   - Оновлює індекс анімації

   - Замінює зображення спрайту на поточний кадр

  

Для гравця анімації мають пріоритет: атака > рух > спокій. Це дозволяє коректно відображати поведінку персонажа в складних ситуаціях.

  

### Система колізій

  

Система колізій використовує механізм прямокутників Pygame для виявлення зіткнень.

  

Особливості реалізації:

1. **Розділення осей**: Для плавного руху колізії перевіряються окремо по осях X та Y

2. **Групи спрайтів**: Використовуються спеціалізовані групи спрайтів (`barriers`, `monsters`, тощо)

3. **Централізована обробка**: Основні перевірки колізій виконуються в методі `Game.update()`

  

Типи колізій у грі:

- Гравець з бар'єрами (блокування руху)

- Снаряди з ворогами (завдання пошкодження)

- Снаряди з бар'єрами (знищення снаряда)

- Гравець з ворогами (поразка)

- Гравець з ключем (підбирання)

- Гравець з дверима (перемога, якщо є ключ)

  

### Керування звуком

  

Звуки в грі керуються через підсистему `pygame.mixer`. Основні компоненти:

  

1. **Фонова музика**: Відтворюється в меню та може бути призупинена під час гри

2. **Звукові ефекти**: Наприклад, звуки натискання кнопок

3. **Керування гучністю**: Кожен звук може мати власну гучність

  

## Інструкція з розширення проекту

  

Для додавання нових функцій до гри рекомендується дотримуватися наступних кроків:

  

### Додавання нових ворогів

  

1. Створіть новий клас, успадкований від `Enemy` або `GameSprite`

2. Підготуйте спрайти та анімації для нового ворога

3. Додайте логіку руху та атаки

4. Створіть екземпляр у класі `Game` та додайте його до групи `monsters`

  

### Додавання нових рівнів

  

1. Розширте клас `Level` або створіть підклас для нового типу рівня

2. Визначте нові бар'єри та об'єкти рівня

3. Додайте новий фон та унікальні елементи

4. Реалізуйте перехід між рівнями в класі `Game`

  

### Додавання нових можливостей гравця

  

1. Розширте клас `Player` новими методами та властивостями

2. Додайте нові анімації у `load_player_animations()`

3. Оновіть обробку введення в `Game.handle_events()`

4. За необхідності створіть нові класи для нових типів снарядів або умінь

  

### Розширення інтерфейсу

  

1. Додайте нові елементи інтерфейсу в `menu.py` або розширте `Game` для відображення статистики

2. За потреби створіть нові класи кнопок або інших елементів інтерфейсу

3. Оновіть обробку подій для взаємодії з новими елементами